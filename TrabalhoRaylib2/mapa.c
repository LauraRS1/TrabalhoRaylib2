
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "jogador.h"
#include "raylib.h"
#include "mapa.h"
#include "desenha.h"
#include "bau.h"

void mapa_carrega(Mapa *mapa) {
    mapa->dimencao = mapa_set_dimencao(mapa->mapa);
    printf("\nDIEMNCAO: %d %d", mapa->dimencao.linha, mapa->dimencao.coluna);
    mapa_set_spawn(mapa);
    printf("\nSPAWN: %d %d", mapa->spawn.linha, mapa->spawn.coluna);
    mapa->porta = ' ';
    mapa->deletado = ' ';
    mapa->escada = 0;
    mapa->bau = 0;
    mapa->chave = 0;
    mapa->jogador = jog_inicializa(mapa->spawn.linha, mapa->spawn.coluna);

    //Váriavél deletado, guarda o char da matriz em que o char 'D' começou a ocupar
    if(mapa->escada == 1){
        mapa->deletado = 'H';
    }
    if(mapa->porta != ' '){
        mapa->deletado = mapa->porta;
    }
    if(mapa->bau == 1){
        mapa->deletado = 'C';
    }

    mapa->qtdBaus = mapa_bau_quantidade(mapa);
    mapa_bau_cria(mapa);
    mapa_bau_gera_itens(mapa);




}
void mapa_movimenta(Mapa *mapa, char direcao) {
    Localizacao local_porta;//Váriavel da localização da porta
    mapa_localiza_jogador(mapa);//Atualiza a localização do jogador
    //variáveis para a localização do jogador
    int x_jog = mapa->jogador.localizacao.linha;
    int y_jog = mapa->jogador.localizacao.coluna;

    char aux;//váriavel de auxilio para trocar os char da matriz de lugar
    int dir_int;//váriavel para somar no indice da matriz

    if((direcao == 'e') || (direcao == 'c')){
        dir_int = -1;
        } else{
            dir_int = 1;
            }
    //Caso for para cima
    if(direcao == 'c'){
        aux = mapa->mapa[x_jog + dir_int][y_jog];

        //Se o jogador estiver numa porta
        if(mapa->porta != ' '){
            mapa_busca_porta(*mapa, mapa->porta, &local_porta);
            mapa->mapa[x_jog][y_jog] = mapa->porta;
            mapa->mapa[local_porta.linha][local_porta.coluna] = 'D';
        }
        //Se o jogador estiver numa escada
        if(mapa->escada == 1){

            //Caso não haja escada acima do jogador
            if(aux == ' ')
                mapa->escada = 0;

            mapa->mapa[x_jog + dir_int][y_jog] = 'D';
            mapa->mapa[x_jog][y_jog] = mapa->deletado;
            mapa->deletado = aux;
        }
    }
    //Caso for para baixo
     if(direcao == 'b'){
        aux = mapa->mapa[x_jog + dir_int][y_jog];

        //Se o jogador estiver num lugar com uma escada embaixo
        if((aux == 'H') && (mapa->escada == 0)){


            mapa->escada = 1;//Jogador agora está numa escada
            mapa->mapa[x_jog][y_jog] = mapa->deletado;
            mapa->mapa[x_jog + dir_int][y_jog] = 'D';
            mapa->deletado = aux;

        //Caso o jogador for descer e estiver numa escada.
        } else if((mapa->escada == 1)  && (aux == 'H')){
            mapa->mapa[x_jog][y_jog] = mapa->deletado;
            mapa->mapa[x_jog + dir_int][y_jog] = 'D';
            mapa->deletado = aux;
        }


    }

    //Caso for para esquerda ou para a direita
    if(((direcao == 'e') || (direcao == 'd')) && ((mapa->mapa[x_jog + 1][y_jog] == 'X') || (mapa->mapa[x_jog + 1][y_jog] == 'H'))){
        aux = mapa->mapa[x_jog][y_jog + dir_int];

            //Caso não for uma parede
            if(aux != 'X'){
                //Se o próximo lugar não for um objeto especial
                if(aux == ' '){
                        //o lugar do jogador que o jogador estará não será um báu
                        mapa->bau = 0;
                        //nem uma escada
                        mapa->escada = 0;
                        //nem uma porta
                        mapa->porta = ' ';



                //Caso próximo lugar seja uma escada...
                }else if(aux == 'H'){
                    mapa->escada = 1;
                    mapa->bau = 0;
                    mapa->porta = ' ';
                //Caso próximo lugar seja um baú...
                }else if(aux == 'C'){
                    mapa->bau = 1;
                    mapa->escada = 0;
                    mapa->porta = ' ';

                    //chama_mensagem_bau();
                //Caso próximo lugar seja uma porta(colocar intervalo de digitos posteriormente)
                }else if((aux > '0') && (aux  <='9')){
                     mapa->porta = mapa->mapa[x_jog][y_jog + dir_int];
                    mapa->bau = 0;
                    mapa->escada = 0;
                }

                mapa->mapa[x_jog][y_jog + dir_int] = 'D';
                mapa->mapa[x_jog][y_jog] = mapa->deletado;
                mapa->deletado = aux;

                /*
                //queda(mapa); // faz o teste da queda
                .......
                .......
                ainda nao esta funcional, por isso o comentario na chamada da função

                */

            }
    }

}

void mapa_localiza_jogador(Mapa *mapa) {
    int i, j;
    for(i = 0; i < mapa->dimencao.linha; i++){
        for(j = 0; j < mapa->dimencao.coluna; j++){
            if(mapa->mapa[i][j] == 'D'){
                mapa->jogador.localizacao.linha = i;
                mapa->jogador.localizacao.coluna = j;
            }
        }
    }
}

/*
    mapa_busca_porta
    Retorna a quantidades de baús que um mapa possui.
    @param mapa: um Mapa
    @param porta: um char referentea porta que o jogador está ocupando
    @param *local_porta: ponteiro para a Localizacao da porta

*/
void mapa_busca_porta(Mapa mapa, char porta, Localizacao *local_porta) {
    int i, j;
    for(i = 0; i < mapa.dimencao.linha; i++){
        for(j = 0; j < mapa.dimencao.coluna; j++){
            if(mapa.mapa[i][j] == porta){
                *local_porta = localizacao_cria(i,j);
            }
        }
    }
}

/*
    mapa_bau_quantidade
    Retorna a quantidades de baús que um mapa possui.
    @param *mapa: ponteiro para um Mapa;

*/
int mapa_bau_quantidade(Mapa *mapa){
    int i, j, b;
    b = 0;
    for(i = 0; i < mapa->dimencao.linha; i++){
        for(j = 0; j < mapa->dimencao.coluna; j++){
            if((mapa->mapa[i][j] == 'C') || ((mapa->mapa[i][j] == 'D') && (mapa->bau == 1)))
                b++;
        }
    }
    return b;
}
/*
    mapa_bau_cria
    Inicializa o vetor de báus com os dados padrões
    @param *mapa: ponteiro para um Mapa;

*/

void mapa_bau_cria(Mapa *mapa){

    int i, j, b;
    b = 0;
        for(i = 0; i < mapa->dimencao.linha; i++){
            for(j = 0; j < mapa->dimencao.coluna; j++){

                if((mapa->mapa[i][j] == 'C') || ((mapa->mapa[i][j] == 'D') && (mapa->bau == 1))){

                    mapa->baus[b].localizacao.linha = i;
                    mapa->baus[b].localizacao.coluna = j;
                    mapa->baus[b].aberto = 0;
                    mapa->baus[b].item = ' ';
                    b++;
                }
            }

        }
}
/*
    mapa_set_dimencao
    Retorna a Localização da última posição ocupada da matriz do mapa
    @param mapa: Um mapa;
*/

Localizacao mapa_set_dimencao(char mapa[MAPA_L][MAPA_C]){
    int i, j;
    Localizacao dimencao;
    i = 0;
    j = 0;
    while(mapa[0][i] == 'X')
        i++;
    while(mapa[j][0] == 'X')
        j++;

    dimencao = localizacao_cria(j, i);
    return dimencao;
}
/*
    Função responsável por atribuir o valor correto para o spawn do mapa, localização em que o jogador começa e retorna ao morrer.
    @param *mapa: ponteiro para um Mapa;
*/
void mapa_set_spawn(Mapa *mapa){
    int i, j;
    for(i = 0; i < mapa->dimencao.linha; i++){
        for(j = 0; j < mapa->dimencao.coluna; j++){
            if(mapa->mapa[i][j] == 'D'){
                mapa->spawn.linha = i;
                mapa->spawn.coluna = j;
            }
        }
    }


}
/*
    Função que gera o item da chave em um baú aleatório
    @param *mapa: ponteiro para um Mapa;
*/
void mapa_gera_chave(Mapa *mapa){
    int rand;
    rand = GetRandomValue(0, mapa->qtdBaus - 1);
    mapa->baus[rand].item = 'P';
}

/*
    Função que gera as bombas de uma determinada fase, número de bombas na fase é igual o número da fase.
    @param *mapa: Ponteiro para um Mapa;
    @param fase: Número da fase
*/
void mapa_gera_bomba(Mapa *mapa, int fase){
    int rand;
    while(fase > 0){
        rand = GetRandomValue(0, mapa->qtdBaus - 1);

        //Atribui a bomba ao báu caso esteja vazio(sem a chave)
        if(mapa->baus[rand].item == ' '){
            mapa->baus[rand].item = 'B';
            fase--;
        }
    }
}
/*  mapa_gera_outros:
    Função que gera o restante dos itens, que apenas somam pontos
    @param *mapa: Ponteiro para um Mapa
    @param fase: Número da fase
*/
void mapa_gera_outros(Mapa *mapa, int fase){
    //Variável limite: Número de Báus do mapa - Quantidade de bombas(fase) - número de chaves(1)
    int limite = mapa->qtdBaus - fase - 1;
    int rand, rand2;//Váriaveis para guardar números aleatórios
    char itens[5] = {'!','@','#','$','%'}; //Vetor com os tipos de bens

     while(limite > 0){
        rand = GetRandomValue(0, mapa->qtdBaus - 1);//Gera um número aleatório entre 0, número referente da primeira posição e o número referente a última posição do vetor de Baús
        rand2 = GetRandomValue(0, 4);//
        //Atribui o item ao baú caso ele esteja sem itens;
        if(mapa->baus[rand].item == ' '){
            mapa->baus[rand].item = itens[rand2];
            limite--;
        }
    }

}
/*  mapa_bau_gera_itens(Mapa *mapa):
    Função que chama as funções que geram os itens dos baús dado o endereço de um mapa
    @param *mapa: Ponteiro para um Mapa

*/
void mapa_bau_gera_itens(Mapa *mapa){
    mapa_gera_chave(mapa);
    mapa_gera_bomba(mapa, mapa->nivel);
    mapa_gera_outros(mapa, mapa->nivel);
}

/*  mapa_seleciona_fase:
    Retorna um Mapa com um mapa atribuido através de um arquivo texto referente a fase da partida
    @param num: interio referente a fase da partida
    @param *tela: ponteiro para a variavél do tipo GameScreen

*/

Mapa mapa_seleciona_fase(int num, GameScreen *tela){
    Mapa mapa;
    char nome_fase[50];
    char linha[MAPA_C];
    mapa.nivel = num;
    int i = 0;
    sprintf(nome_fase, "fase%d.txt", num);
    //printf("%s\n", nome_fase);
    FILE *arquivo;
    if((arquivo = fopen(nome_fase, "r"))){
        while(fgets(linha, MAPA_C, arquivo) != NULL){
            printf("mapa[%d]%s", i, linha);
            strcpy(mapa.mapa[i], linha);


            i++;
        }
    fclose(arquivo);
    //Se não tiver arquivos para ler, pula para tela de encerramento
    }else{
        *tela = ENDING;
    }

    return mapa;
}
/*
    mapa_carrega_proxima_fase_e_jogador:
    Dado um ponteiro para um mapa e um jogador, inicia as variáveis restantes do mapa e atribui asinformações do jogador dado.
    @param *mapa: ponteiro para um mapa
    @param jogador: ponteiro para a variavél do tipo GameScreen

*/
void mapa_carrega_proxima_fase_e_jogador(Mapa *mapa, Jogador jogador) {
    mapa->dimencao = mapa_set_dimencao(mapa->mapa);
    printf("\nDIEMNCAO: %d %d", mapa->dimencao.linha, mapa->dimencao.coluna);
    mapa_set_spawn(mapa);
    printf("\nSPAWN: %d %d", mapa->spawn.linha, mapa->spawn.coluna);
    mapa->porta = ' ';
    mapa->deletado = ' ';
    mapa->escada = 0;
    mapa->bau = 0;
    mapa->chave = 0;
    mapa->jogador = jogador;
    mapa->jogador.localizacao.linha = mapa->spawn.linha;
    mapa->jogador.localizacao.coluna = mapa->spawn.coluna;

    //Váriavél deletado, guarda o char da matriz em que o char 'D' começou a ocupar
    if(mapa->escada == 1){
        mapa->deletado = 'H';
    }
    if(mapa->porta != ' '){
        mapa->deletado = mapa->porta;
    }
    if(mapa->bau == 1){
        mapa->deletado = 'C';
    }

    mapa->qtdBaus = mapa_bau_quantidade(mapa);
    mapa_bau_cria(mapa);
    mapa_bau_gera_itens(mapa);




}
/*
void mapa_imprime(Mapa mapa) {
    int i, j;
    for(i = 0; i < mapa.dimencao.linha; i++){
        for(j = 0; j < mapa.dimencao.coluna; j++){
            printf("%c", mapa.mapa[i][j]);
        }
        printf("\n");
    }
    jog_print_info(mapa.jogador);
}
*/
/*
void chama_mensagem_bau() {
    char abrir;
    printf("\nVoce encontrou um bau. Deseja abri-lo? [s]im");
    scanf("%c", &abrir);

    if(toupper(abrir) == 'S') {
        // aqui a função que seleciona um item
    }
}
*/
// função recursiva da queda
// chamar apos movimento lateral movimento para os lados
// ainda não está funcional. A matriz na linha abaixo nao esta representando o char correto
/*
void queda(Mapa *mapa) {
    //variáveis para a localização do jogador
    mapa_localiza_jogador(mapa);//Atualiza a localização do jogador
    int x_jog = mapa->jogador.localizacao.linha;
    int y_jog = mapa->jogador.localizacao.coluna;
    char aux; // guarda o conteudo da matriz abaixo do jogador

    printf("\nchar abaixo: %c", mapa->mapa[x_jog - 1][y_jog]);
    if(mapa->mapa[x_jog - 1][y_jog] == ' ') { // se jogador esta flutuando
        mapa->mapa[x_jog][y_jog - 1] = 'D'; // // diminui linha do jogador na matriz
        mapa->mapa[x_jog][y_jog] = ' ';

        queda(mapa); // continua verificando proximas linhas
    } else if(mapa->mapa[x_jog - 1][y_jog] != 'X') { // se jogador sobre um objeto diferente de parede
        aux = mapa->mapa[x_jog - 1][y_jog]; // apenas atualiza jogador, mas nao chama função
        mapa->mapa[x_jog][y_jog - 1] = 'D';
        mapa->mapa[x_jog][y_jog] = aux;
    }

}
*/



